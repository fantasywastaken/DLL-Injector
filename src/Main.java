import com.github.weisj.darklaf.LafManager;import com.github.weisj.darklaf.theme.OneDarkTheme;import injector.Injector;import javax.swing.*;import javax.swing.table.*;import java.awt.*;import java.awt.event.*;import java.io.*;import java.util.*;import java.util.List;import java.util.concurrent.*;import javax.swing.filechooser.FileNameExtensionFilter;public class Main extends JFrame {    private JTable processTable;    private DefaultTableModel tableModel;    private JTextField dllPathField;    private JLabel statusLabel;    private JButton injectButton;    private JTextField searchField;    private ScheduledExecutorService scheduler;    public Main() {        super("Advanced DLL Injector");        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        setSize(800, 600);        setLocationRelativeTo(null);        setResizable(false);        JPanel mainPanel = new JPanel(new BorderLayout(10, 10));        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));        mainPanel.setBackground(new Color(37, 41, 48));        mainPanel.add(createStatusPanel(), BorderLayout.NORTH);        mainPanel.add(createProcessPanel(), BorderLayout.CENTER);        mainPanel.add(createControlPanel(), BorderLayout.SOUTH);        setContentPane(mainPanel);        refreshProcessList();        startProcessRefreshing();        addWindowListener(new WindowAdapter() {            @Override            public void windowClosing(WindowEvent e) {                if (scheduler != null) {                    scheduler.shutdown();                }            }        });    }    private JPanel createStatusPanel() {        JPanel panel = new JPanel(new BorderLayout());        panel.setOpaque(false);        statusLabel = new JLabel("Ready");        statusLabel.setForeground(new Color(220, 220, 220));        statusLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 5, 0));        panel.add(statusLabel, BorderLayout.WEST);        return panel;    }    private JPanel createProcessPanel() {        JPanel panel = new JPanel(new BorderLayout(0, 10));        panel.setOpaque(false);        JLabel titleLabel = new JLabel("Running Processes");        titleLabel.setForeground(new Color(200, 200, 200));        titleLabel.setFont(new Font("Segoe UI", Font.BOLD, 16));        JPanel searchPanel = new JPanel(new BorderLayout(5, 0));        searchPanel.setOpaque(false);        searchField = new JTextField();        searchField.setToolTipText("Search processes");        searchField.getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {            @Override            public void insertUpdate(javax.swing.event.DocumentEvent e) {                filterProcessList();            }            @Override            public void removeUpdate(javax.swing.event.DocumentEvent e) {                filterProcessList();            }            @Override            public void changedUpdate(javax.swing.event.DocumentEvent e) {                filterProcessList();            }        });        JButton refreshButton = new JButton("Refresh");        refreshButton.setFocusPainted(false);        refreshButton.addActionListener(e -> refreshProcessList());        searchPanel.add(new JLabel("Search: "), BorderLayout.WEST);        searchPanel.add(searchField, BorderLayout.CENTER);        searchPanel.add(refreshButton, BorderLayout.EAST);        String[] columnNames = {"Process Name (PID)"};        tableModel = new DefaultTableModel(columnNames, 0) {            @Override            public boolean isCellEditable(int row, int column) {                return false;            }        };        processTable = new JTable(tableModel);        processTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);        processTable.setRowHeight(25);        processTable.setShowVerticalLines(false);        processTable.getTableHeader().setReorderingAllowed(false);        processTable.getTableHeader().setResizingAllowed(false);        JScrollPane scrollPane = new JScrollPane(processTable);        scrollPane.setBorder(BorderFactory.createLineBorder(new Color(70, 70, 70)));        panel.add(titleLabel, BorderLayout.NORTH);        panel.add(searchPanel, BorderLayout.SOUTH);        panel.add(scrollPane, BorderLayout.CENTER);        return panel;    }    private JPanel createControlPanel() {        JPanel panel = new JPanel(new BorderLayout(10, 10));        panel.setOpaque(false);        panel.setBorder(BorderFactory.createCompoundBorder(                BorderFactory.createMatteBorder(1, 0, 0, 0, new Color(70, 70, 70)),                BorderFactory.createEmptyBorder(10, 0, 0, 0)        ));        JPanel dllPathPanel = new JPanel(new BorderLayout(5, 0));        dllPathPanel.setOpaque(false);        JLabel dllPathLabel = new JLabel("Dll Path:");        dllPathLabel.setForeground(new Color(200, 200, 200));        dllPathField = new JTextField();        dllPathField.setEditable(false);        Dimension fieldSize = searchField.getPreferredSize();        dllPathField.setPreferredSize(new Dimension(fieldSize.width, fieldSize.height));        JButton browseButton = new JButton("Browse");        browseButton.setFocusPainted(false);        browseButton.addActionListener(e -> browseDllFile());        injectButton = new JButton("Inject");        injectButton.setFocusPainted(false);        injectButton.setBackground(new Color(60, 130, 200));        injectButton.setForeground(Color.WHITE);        injectButton.addActionListener(e -> injectDll());        Dimension buttonSize = new Dimension(browseButton.getPreferredSize());        browseButton.setPreferredSize(buttonSize);        injectButton.setPreferredSize(buttonSize);        dllPathPanel.add(dllPathLabel, BorderLayout.WEST);        dllPathPanel.add(dllPathField, BorderLayout.CENTER);        dllPathPanel.add(browseButton, BorderLayout.EAST);        JPanel injectPanel = new JPanel(new BorderLayout());        injectPanel.setOpaque(false);        injectPanel.add(injectButton, BorderLayout.EAST);        panel.add(dllPathPanel, BorderLayout.CENTER);        panel.add(injectPanel, BorderLayout.EAST);        return panel;    }    private void startProcessRefreshing() {        scheduler = Executors.newSingleThreadScheduledExecutor();        scheduler.scheduleAtFixedRate(this::refreshProcessList, 10, 10, TimeUnit.SECONDS);    }    private void refreshProcessList() {        SwingUtilities.invokeLater(() -> {            statusLabel.setText("Refreshing process list...");            int selectedRow = processTable.getSelectedRow();            String selectedProcessInfo = selectedRow >= 0 ? (String) tableModel.getValueAt(selectedRow, 0) : null;            tableModel.setRowCount(0);            try {                List<ProcessInfo> processes = getRunningProcesses();                for (ProcessInfo process : processes) {                    tableModel.addRow(new Object[]{                            process.getName() + " (" + process.getPid() + ")"                    });                }                if (selectedProcessInfo != null) {                    for (int i = 0; i < tableModel.getRowCount(); i++) {                        if (tableModel.getValueAt(i, 0).equals(selectedProcessInfo)) {                            processTable.setRowSelectionInterval(i, i);                            break;                        }                    }                }                statusLabel.setText("Process list refreshed. " + processes.size() + " processes found.");            } catch (Exception e) {                statusLabel.setText("Error refreshing process list: " + e.getMessage());            }        });    }    private void filterProcessList() {        String searchText = searchField.getText().toLowerCase();        TableRowSorter<TableModel> sorter = new TableRowSorter<>(processTable.getModel());        processTable.setRowSorter(sorter);        if (searchText.trim().isEmpty()) {            sorter.setRowFilter(null);        } else {            sorter.setRowFilter(RowFilter.regexFilter("(?i)" + searchText));        }    }    private List<ProcessInfo> getRunningProcesses() {        List<ProcessInfo> processes = new ArrayList<>();        try {            Process process = Runtime.getRuntime().exec(System.getenv("windir") + "\\" + "system32" + "\\" + "tasklist.exe /FO CSV /NH");            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));            String line;            while ((line = reader.readLine()) != null) {                String[] parts = line.split(",");                if (parts.length >= 2) {                    String name = parts[0].replace("\"", "");                    String pid = parts[1].replace("\"", "");                    processes.add(new ProcessInfo(pid, name));                }            }            reader.close();            Collections.sort(processes);        } catch (IOException e) {            JOptionPane.showMessageDialog(this,                    "Error getting process list: " + e.getMessage(),                    "Error", JOptionPane.ERROR_MESSAGE);        }        return processes;    }    private void browseDllFile() {        JFileChooser fileChooser = new JFileChooser();        fileChooser.setDialogTitle("Select DLL File");        fileChooser.setFileFilter(new FileNameExtensionFilter("DLL Files", "dll"));        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {            File selectedFile = fileChooser.getSelectedFile();            dllPathField.setText(selectedFile.getAbsolutePath());        }    }    private void injectDll() {        int selectedRow = processTable.getSelectedRow();        if (selectedRow < 0) {            JOptionPane.showMessageDialog(this,                    "Please select a process from the list.",                    "No Process Selected", JOptionPane.WARNING_MESSAGE);            return;        }        int modelRow = processTable.convertRowIndexToModel(selectedRow);        String processInfo = (String) tableModel.getValueAt(modelRow, 0);        String processName = processInfo.substring(0, processInfo.lastIndexOf(" (")).trim();        String dllPath = dllPathField.getText().trim();        if (dllPath.isEmpty()) {            JOptionPane.showMessageDialog(this,                    "Please specify the DLL path.",                    "No DLL Path", JOptionPane.WARNING_MESSAGE);            return;        }        File file = new File(dllPath);        if (!file.exists() || !file.isFile()) {            JOptionPane.showMessageDialog(this,                    "The specified DLL file does not exist.",                    "Invalid DLL Path", JOptionPane.ERROR_MESSAGE);            return;        }        int result = JOptionPane.showConfirmDialog(this,                "Are you sure you want to inject '" + file.getName() + "' into process '" + processName + "'?",                "Confirm Injection", JOptionPane.YES_NO_OPTION);        if (result == JOptionPane.YES_OPTION) {            new SwingWorker<Boolean, Void>() {                @Override                protected Boolean doInBackground() {                    statusLabel.setText("Injecting DLL into " + processName + "...");                    injectButton.setEnabled(false);                    try {                        Injector.start(processName, dllPath, 10);                        return true;                    } catch (Exception e) {                        return false;                    }                }                @Override                protected void done() {                    try {                        boolean success = get();                        if (success) {                            statusLabel.setText("DLL successfully injected into " + processName);                            JOptionPane.showMessageDialog(Main.this,                                    "DLL has been successfully injected!",                                    "Injection Successful", JOptionPane.INFORMATION_MESSAGE);                        } else {                            statusLabel.setText("Failed to inject DLL");                            JOptionPane.showMessageDialog(Main.this,                                    "Failed to inject the DLL. Check the console for details.",                                    "Injection Failed", JOptionPane.ERROR_MESSAGE);                        }                    } catch (Exception e) {                        statusLabel.setText("Error during injection: " + e.getMessage());                        JOptionPane.showMessageDialog(Main.this,                                "Error during injection: " + e.getMessage(),                                "Injection Error", JOptionPane.ERROR_MESSAGE);                    } finally {                        injectButton.setEnabled(true);                    }                }            }.execute();        }    }    private static class ProcessInfo implements Comparable<ProcessInfo> {        private final String pid;        private final String name;        public ProcessInfo(String pid, String name) {            this.pid = pid;            this.name = name;        }        public String getPid() {            return pid;        }        public String getName() {            return name;        }        @Override        public int compareTo(ProcessInfo other) {            return name.compareToIgnoreCase(other.name);        }    }    public static void main(String[] args) {        try {            LafManager.install(new OneDarkTheme());        } catch (Exception ignored) {}        SwingUtilities.invokeLater(() -> {            Main app = new Main();            app.setVisible(true);        });    }}