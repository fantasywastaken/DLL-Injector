package injector;import com.sun.jna.Native;import com.sun.jna.Pointer;import com.sun.jna.ptr.IntByReference;import com.sun.jna.ptr.PointerByReference;import interfaces.Kernel32;import java.io.BufferedReader;import java.io.InputStreamReader;public class Injector {    public static void start(String processName, String dllPath, int attemptCount) {        int processID = Injector.getProcessID(processName);        if (processID != 0) {            boolean injected = false;            int attempts = 0;            while (!injected && attempts < attemptCount) {                attempts++;                Injector.injectDLL(processID, dllPath);                injected = Injector.isModuleLoaded(processID, dllPath);            }        }    }    public static void injectDLL(int processId, String dllPath) {        Pointer hProcess = Kernel32.INSTANCE.OpenProcess(Kernel32.PROCESS_ALL_ACCESS, false, processId);        if (hProcess == null || Pointer.nativeValue(hProcess) == 0) {            return;        }        Pointer remoteMemory = Kernel32.INSTANCE.VirtualAllocEx(hProcess, null, dllPath.length() + 1, Kernel32.MEM_COMMIT | Kernel32.MEM_RESERVE, Kernel32.PAGE_EXECUTE_READWRITE);        if (remoteMemory == null || Pointer.nativeValue(remoteMemory) == 0) {            Kernel32.INSTANCE.CloseHandle(hProcess);            return;        }        IntByReference written = new IntByReference();        if (!Kernel32.INSTANCE.WriteProcessMemory(hProcess, remoteMemory, dllPath.getBytes(), dllPath.length() + 1, written)) {            Kernel32.INSTANCE.VirtualFreeEx(hProcess, remoteMemory, 0, Kernel32.MEM_RELEASE);            Kernel32.INSTANCE.CloseHandle(hProcess);            return;        }        Pointer kernel32Handle = Kernel32.INSTANCE.GetModuleHandleA("kernel32.dll");        if (kernel32Handle == null || Pointer.nativeValue(kernel32Handle) == 0) {            Kernel32.INSTANCE.VirtualFreeEx(hProcess, remoteMemory, 0, Kernel32.MEM_RELEASE);            Kernel32.INSTANCE.CloseHandle(hProcess);            return;        }        Pointer loadLibrary = Kernel32.INSTANCE.GetProcAddress(kernel32Handle, "LoadLibraryA");        if (loadLibrary == null || Pointer.nativeValue(loadLibrary) == 0) {            Kernel32.INSTANCE.VirtualFreeEx(hProcess, remoteMemory, 0, Kernel32.MEM_RELEASE);            Kernel32.INSTANCE.CloseHandle(hProcess);            return;        }        PointerByReference threadId = new PointerByReference();        Pointer hThread = Kernel32.INSTANCE.CreateRemoteThread(hProcess, null, 0, loadLibrary, remoteMemory, 0, threadId);        if (hThread == null || Pointer.nativeValue(hThread) == 0) {            Kernel32.INSTANCE.VirtualFreeEx(hProcess, remoteMemory, 0, Kernel32.MEM_RELEASE);            Kernel32.INSTANCE.CloseHandle(hProcess);            return;        }        try {            Thread.sleep(1000);        } catch (InterruptedException ignored) {}        Kernel32.INSTANCE.CloseHandle(hThread);        Kernel32.INSTANCE.CloseHandle(hProcess);    }    public static boolean isModuleLoaded(int processId, String dllPath) {        Pointer snapshot = Kernel32.INSTANCE.CreateToolhelp32Snapshot(Kernel32.TH32CS_SNAPMODULE, processId);        if (snapshot == null || snapshot.equals(Kernel32.INVALID_HANDLE_VALUE)) {            return false;        }        Kernel32.MODULEENTRY32W moduleEntry = new Kernel32.MODULEENTRY32W();        moduleEntry.dwSize = moduleEntry.size();        boolean moduleFound = false;        if (Kernel32.INSTANCE.Module32FirstW(snapshot, moduleEntry)) {            do {                String moduleName = Native.toString(moduleEntry.szModule);                if (dllPath.endsWith(moduleName)) {                    moduleFound = true;                    break;                }            } while (Kernel32.INSTANCE.Module32NextW(snapshot, moduleEntry));        }        Kernel32.INSTANCE.CloseHandle(snapshot);        return moduleFound;    }    public static int getProcessID(String processName) {        int pid = 0;        try {            String line;            Process process = Runtime.getRuntime().exec(System.getenv("windir") + "\\" + "system32" + "\\" + "tasklist.exe /FI \"IMAGENAME eq " + processName + "\" /NH");            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));            while ((line = bufferedReader.readLine()) != null) {                if (line.contains(processName)) {                    String[] split = line.split("\\s+");                    pid = Integer.parseInt(split[1]);                    break;                }            }            bufferedReader.close();        } catch (Exception ignored) {}        return pid;    }}